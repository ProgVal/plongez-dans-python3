---
title: Itérateurs avancés
status: En cours
permalink: advanced-iterators.html
---
<!DOCTYPE html>
<meta charset=utf-8>
<title>Advanced Iterators - Dive Into Python 3</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<style>
body{counter-reset:h1 8}
mark{display:inline}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta name=viewport content='initial-scale=1.0'>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input type=search name=q size=25 placeholder="powered by Google&trade;">&nbsp;<input type=submit name=sa value=Search></div></form>
<p>You are here: <a href=index.html>Home</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#advanced-iterators>Dive Into Python 3</a> <span class=u>&#8227;</span>
<p id=level>Difficulty level: <span class=u title=advanced>&#x2666;&#x2666;&#x2666;&#x2666;&#x2662;</span>
<h1>Advanced Iterators</h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span> Great fleas have little fleas upon their backs to bite &#8217;em,<br>And little fleas have lesser fleas, and so ad infinitum. <span class=u>&#x275E;</span><br>&mdash; Augustus De Morgan
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Diving In</h2>
<p class=f>Tout comme <a href=regular-expressions.html>les expressions rationnelles</a> mettent <a href=strings.html>les chaines</a> sous stéroïdes, le module <code>itertools</code> met <a href=iterators.html>les iterateurs</a> sous stéroïdes. Mais d’abord, je voudrais vous montrer un défi classique.

<pre class=nd><code>HAWAII + IDAHO + IOWA + OHIO == STATES
510199 + 98153 + 9301 + 3593 == 621246

H = 5
A = 1
W = 0
I = 9
D = 8
O = 3
S = 6
T = 2
E = 4</code></pre>

<p>Des défis comme celui-ci sont appelés <i>cryptarithme</i> ou <i>alphamétique</i>. Les lettres épellées sont des mots réels, mais si vous remplacez chaque lettre par un nombre de <code>0</code> à <code>9</code>, ils deviennent une équation arithmétique. L’astuce est de trouver quelle lettre correspond à chaque chiffre. Toutes les occurences de chaque lettre doivent correspondre au même chiffre, aucun chiffre ne peut être répété, et aucun «&nbsp;mot&nbsp;» ne peut commencer avec le chiffre 0.

<aside>Le défi alphamétique le plus connu est <code>SEND + MORE = MONEY</code>.</aside>

<p>Dans ce chapitre, nous allons plonger dans un programme Python incroyable écrit à l’origine par Raymond Hettinger. Ce programme résout les défis alphamétiques <em>en seulement quatorze lignes de code</em>.

<p class=d>[<a href=examples/alphametics.py>télécharger <code>alphametics.py</code></a>]
<pre class=pp><code>import re
import itertools

def solve(puzzle):
    words = re.findall('[A-Z]+', puzzle.upper())
    unique_characters = set(''.join(words))
    assert len(unique_characters) &lt;= 10, 'Too many letters'
    first_letters = {word[0] for word in words}
    n = len(first_letters)
    sorted_characters = ''.join(first_letters) + \
        ''.join(unique_characters - first_letters)
    characters = tuple(ord(c) for c in sorted_characters)
    digits = tuple(ord(c) for c in '0123456789')
    zero = digits[0]
    for guess in itertools.permutations(digits, len(characters)):
        if zero not in guess[:n]:
            equation = puzzle.translate(dict(zip(characters, guess)))
            if eval(equation):
                return equation

if __name__ == '__main__':
    import sys
    for puzzle in sys.argv[1:]:
        print(puzzle)
        solution = solve(puzzle)
        if solution:
            print(solution)</code></pre>

<p>Vous pouvez lancer le programme depuis la ligne de commande. Sous Linux, il ressemblerait à ceci. (Cela peu prendre du temps selon la vitesse de votre ordinateur, et il n’y a pas de barre de progression. Soyez patient-e&nbsp;!)

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 alphametics.py "HAWAII + IDAHO + IOWA + OHIO == STATES"</kbd>
<samp>HAWAII + IDAHO + IOWA + OHIO = STATES
510199 + 98153 + 9301 + 3593 == 621246</samp>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 alphametics.py "I + LOVE + YOU == DORA"</kbd>
<samp>I + LOVE + YOU == DORA
1 + 2784 + 975 == 3760</samp>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 alphametics.py "SEND + MORE == MONEY"</kbd>
<samp>SEND + MORE == MONEY
9567 + 1085 == 10652</samp></pre>

<p class=a>&#x2042;

<h2 id=re-findall>Trouver toutes les occurences d’un motif</h2>

<p>La première chose que fait ce résolveur d’alphamétique est trouver toutes les lettres (A&ndash;Z) dans le défi.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import re</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.findall('[0-9]+', '16 2-by-4s in rows of 8')</kbd>  <span class=u>&#x2460;</span></a>
<samp class=pp>['16', '2', '4', '8']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.findall('[A-Z]+', 'SEND + MORE == MONEY')</kbd>     <span class=u>&#x2461;</span></a>
<samp class=pp>['SEND', 'MORE', 'MONEY']</samp></pre>
<ol>
<li>Le module <code>re</code> est l’implémentation de Python des <a href=regular-expressions.html>expressions rationnelles</a>. Il a une fonction habile nommée <code>findall()</code> qui prend une expression rationnelle et une chaine, et trouve toutes les occurences du motif dans la chaine. Dans ce cas, le motif correspond aux séquences de nombres. La fonction <code>findall()</code> retourne une liste de toutes les sous-chaines qui correspondent au motif.
<li>Voici une expression rationnelle qui détecte les séquences de lettres. À nouveau, la valeur de retour est une liste, et chaque élément de la liste est une chaine qui correspondait au motif de l’expression rationnelle.
</ol>

<p>Voici un autre exemple qui stimulera un peu votre cerveau.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>re.findall(' s.*? s', "The sixth sick sheikh's sixth sheep's sick.")</kbd>
<samp class=pp>[' sixth s', " sheikh's s", " sheep's s"]</samp></pre>

<aside>Ceci est le <a href="https://fr.wikipedia.org/wiki/Virelangue">virelangue</a> le plus complexe de l’anglais.</aside>

<p>Surpri-e&nbsp;? L’expression rationnelle cherche une espace, un <code>s</code>, puis la plus petite série possible de n’importe quel caractère (<code>.*?</code>), puis une espace, puis un autre <code>s</code>. Eh bien, en regardant la chaine d’entrée, je trouve cinq correspondances&nbs;:

<ol>
<li><code>The<mark> sixth s</mark>ick sheikh's sixth sheep's sick.</code>
<li><code>The sixth<mark> sick s</mark>heikh's sixth sheep's sick.</code>
<li><code>The sixth sick<mark> sheikh's s</mark>ixth sheep's sick.</code>
<li><code>The sixth sick sheikh's<mark> sixth s</mark>heep's sick.</code>
<li><code>The sixth sick sheikh's sixth<mark> sheep's s</mark>ick.</code>
</ol>

<p>Mais la fonction <code>re.findall()</code> n’en a renvoyé que trois. Plus spécifiquement, elle a renvoyé la première, la troisième, et la cinquième. Pourquoi donc&nbsp;? Parce qu’<em>elle ne retourne pas de sous-chaines qui se recouvrent</em>. La première recouvre la seconde, donc la première est retournée et la seconde est sautée. Puis, la troisième recouvre la seconde, donc la troisième est renvoyée et la quatrième sautée. Enfin, la cinquième est retournée. Trois correspondances, pas cinq.

<p>Ceci n’a rien à voir avec le résolveur d’alphanumérique&nbsp;; je considérais seulement que c’était intéressant.

<p class=a>&#x2042;

<h2 id=unique-items>Trouver les éléments uniques d’une séquence</h2>

<p>Les <a href=native-datatypes.html#sets>ensembles</a> rendent trivial la recherche d’éléments uniques dans une séquence.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = ['The', 'sixth', 'sick', "sheik's", 'sixth', "sheep's", 'sick']</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>set(a_list)</kbd>                      <span class=u>&#x2460;</span></a>
<samp class=pp>{'sixth', 'The', "sheep's", 'sick', "sheik's"}</samp>
<samp class=p>>>> </samp><kbd class=pp>a_string = 'EAST IS EAST'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>set(a_string)</kbd>                    <span class=u>&#x2461;</span></a>
<samp class=pp>{'A', ' ', 'E', 'I', 'S', 'T'}</samp>
<samp class=p>>>> </samp><kbd class=pp>words = ['SEND', 'MORE', 'MONEY']</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>''.join(words)</kbd>                   <span class=u>&#x2462;</span></a>
<samp class=pp>'SENDMOREMONEY'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>set(''.join(words))</kbd>              <span class=u>&#x2463;</span></a>
<samp class=pp>{'E', 'D', 'M', 'O', 'N', 'S', 'R', 'Y'}</samp></pre>
<ol>
<li>Étant doné une liste de plusieurs chaines, la fonction <code>set()</code> renvoie un ensemble de chaines uniques de la liste. Cela a du sens si vous y pensez comme une boucle <code>for</code>. Prenez le premier élément de la liste, ajoutez-le dans l’ensemble. Puis le second. Le troisième. Le quatrième. Le cinquième&nbsp;&mdash;&nbsp;euh, attendez, celui-ci était déjà dans l’ensemble, donc il se retrouve listé seulement une fois, parce que les ensembles de Python n’autorisent pas les dupliquats. Puis le sixième. Puis le septième&nbsp;&mdash;&nbsp;à nouveau, un doublon, donc il ne se fait lister qu’une fois. Le résultat final&nbsp;? Tous les élements, uniques, de la liste originale, sans aucun doublon. La liste originale n’a même pas besoin d’être pré-triée.
<li>La même technique fonctionne sur les chaines, puisque les haines ne sont que des suites de caractères.
<li>Étant donné une liste de chaines, <code>''.join(<var>une_liste</var>)</code> concatène toutes les chaines en une seule.
<li>Donc, étant donné une liste de chaine, cette ligne renvoie tous les caractères, uniques, qui apparaissent dans la chaine, sans doublon.
</ol>

<p>Le résolveur d’alphamétique utilise cette technique pour construire l’ensemble de tous les caractères de l’ensemble.

<pre class='nd pp'><code>unique_characters = set(''.join(words))</code></pre>

<p>Cette liste est utilisée par la suite pour assigner des chiffres aux caractères, pendant que le résolveur itère parmi les solutions possibles.

<p class=a>&#x2042;

<h2 id=assert>Faire des assertions</h2>

<p>Comme beaucoup de langages de programmation, Python a une instruction <code>assert</code>. Voici comment il fonctionne.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>assert 1 + 1 == 2</kbd>                                     <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>assert 1 + 1 == 3</kbd>                                     <span class=u>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
AssertionError</samp>
<a><samp class=p>>>> </samp><kbd class=pp>assert 2 + 2 == 5, "Only for very large values of 2"</kbd>  <span class=u>&#x2462;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
AssertionError: Only for very large values of 2</samp></pre>
<ol>
<li>L’instruction <code>assert</code> est suivie de n’importe quelle expression Python valide. Dans ce cas, l’expression <code>1 + 1 == 2</code> est évaluée à <code>True</code>, donc l’instruction <code>assert</code> ne fait rien.
<li>Cependant, si Python évalue l’expression à <code>False</code>, l’instruction <code>assert</code> lèvera une <code>AssertionError</code>.
<li>Vous pouvez également inclure un message humainemnt lisible qui sera affiché si l’<code>AssertionError</code> est levée.
</ol>

<p>Ainsi, cette ligne&nbsp;:

<pre class='nd pp'><code>assert len(unique_characters) &lt;= 10, 'Too many letters'</code></pre>

<p>&hellip; est équivalente à ceci&nbsp;:

<pre class='nd pp'><code>if len(unique_characters) > 10:
    raise AssertionError('Too many letters')</code></pre>

<p>Le résolveur d’alphamétique utilise cette instruction <code>assert</code> pour s’arrêter immédiatement si le défi contient plus de dix lettres différences. Étant donné que chaque lettre est associée à un chiffre unique, et qu’il y a seulement dix chiffres, un défiavec plus de dix lettres différentes ne peut pas avoir de solution.

<p class=a>&#x2042;

<h2 id=generator-expressions>Expressions génératrices</h2>

<p>Une expression génératrice est comme une <a href=generators.html>fonction génératrice</a>, sans fonction.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>unique_characters = {'E', 'D', 'M', 'O', 'N', 'S', 'R', 'Y'}</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>gen = (ord(c) for c in unique_characters)</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>gen</kbd>                                        <span class=u>&#x2461;</span></a>
<samp class=pp>&lt;generator object &lt;genexpr> at 0x00BADC10></samp>
<a><samp class=p>>>> </samp><kbd class=pp>next(gen)</kbd>                                  <span class=u>&#x2462;</span></a>
<samp class=pp>69</samp>
<samp class=p>>>> </samp><kbd class=pp>next(gen)</kbd>
<samp class=pp>68</samp>
<a><samp class=p>>>> </samp><kbd class=pp>tuple(ord(c) for c in unique_characters)</kbd>   <span class=u>&#x2463;</span></a>
<samp class=pp>(69, 68, 77, 79, 78, 83, 82, 89)</samp></pre>
<ol>
<li>Une expression génératrice est comme une fonction anonyme qui prodit des valeurs. L’expression en elle-même ressemble un peu à une <a href=comprehensions.html#listcomprehension>liste par compréhension</a>, à part qu’elle est entourée de parenthèses plutôt que de crochets.
<li>L’expression génératrice renvoie&hellip; un itérateur.
<li>Appeller <code>next(<var>gen</var>)</code> retourne la valeur suivante de l’itérateur.
<li>Si vous le souhaitez, vous pouvez itérer à travers toutes les valeurs possibles et renvoyer un n-uplet, une liste, ou un ensemble, en passant l’expression génératrice à <code>tuple()</code>, <code>list()</code>, ou <code>set()</code>. Dans ces cas, vous n’avez pas besoin d’une paire supplémentaire de parenthèses&nbsp;&mdash;&nbsp;passez tout simplement l’expression <code>ord(c) for c in unique_characters</code> «&nbsp;brute&nbsp;» à la fonction <code>tuple()</code>, et Python devinera qu’il s’agit d’une expression génératrice.
</ol>

<blockquote class=note>
<p><span class=u>&#x261E;</span>Utiliser une expression génératrice plutôt qu’une liste par compréhension peut économiser à la fois du <abbr>CPU</abbr> et de la <abbr>RAM</abbr>. Si vous voulez construire une liste et la jeter (par exemple la passer à <code>tuple()</code> ou <code>set()</code>), utilisez une expression génératrice à la place&nbsp;!
</blockquote>

<p>Voici une autre façon d’accomplir la même chose, en utilisant une <a href=generators.html>fonction génératrice</a>&nbsp;:

<pre class='nd pp'><code>def ord_map(a_string):
    for c in a_string:
        yield ord(c)

gen = ord_map(unique_characters)</code></pre>

<p>L’expression génératrice est méthode plus compacte mais équivalente.

<p class=a>&#x2042;

<h2 id=permutations>Calculer des permutation&hellip; La Méthode Fénéante&nbsp;!</h2>

<p>Tout d’abord, que sont donc des permutations&nbsp;? Les permutations sont un concept mathématique. (Il y a en fait plusieurs définition, en fonction du type de mathématiques que vous faites. Ici je parle de combinatoire, mais si ça ne vous dit rien, ne paniquez pas. Comme toujours, <a href=https://fr.wikipedia.org/wiki/Permutation>Wikipédia est votre amie</a>.)

<p>L’idée est d’avoir une liste de choses (des nombres, des lettres, des lettres, des ours dansants, &helli;) et trouver toutes les possibilités de les partager en des listes plus petites. Toutes les listes plus petite ont la même taille, qui peuvent être de longueur quelconque entre 1 et le nombre total d’éléments. Oh, et rien ne peut répéter. Les mathématicien-ne-s disent des choses comme trouver les permutations de trois éléments différents en en prenant deux à la fois, ce qui signifie que vous avez une suite de trois éléments et que vous voulez trouver tous les ordres possibles.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>import itertools</kbd>                              <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>perms = itertools.permutations([1, 2, 3], 2)</kbd>  <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>                                   <span class=u>&#x2462;</span></a>
<samp class=pp>(1, 2)</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>(1, 3)</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<a><samp class=pp>(2, 1)</samp>                                            <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>(2, 3)</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>(3, 1)</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>(3, 2)</samp>
<a><samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>                                   <span class=u>&#x2464;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
StopIteration</samp></pre>
<ol>
<li>Le module <code>itertools</code> a toutes sortes de trucs amusant, y compris une fonction <code>permutations()</code> qui fait le gros du travail de la recherche de permutations.
<li>La fonction <code>permutations()</code> prend une suite (ceci est une liste de trois entiers) et un nombre, qui est le nombre d’élements que vous voulez dans chacun des groupes plus petit. La fonction retourne un itérateur, que vous pouvez utiliser dans une boucle <code>for</code> ou n’importe quel autre chose qui itère. Ici je parcours l’itérateur manuellement pour afficher toutes les valeurs.
<li>La première permutation de <code>[1, 2, 3]</code> en en prenant deux à la fois est <code>(1, 2)</code>.
<li>Notez que les permutations sont ordonnées&nbsp;: <code>(2, 1)</code> est différent de <code>(1, 2)</code>.
<li>C’est tout&nbsp;! Ce sont toutes les permutations de <code>[1, 2, 3]</code> en prenant deux éléments à la fois. Les paires comme <code>(1, 1)</code> et <code>(2, 2)</code> ne s’affichent jamais, car elles contiennent des répétitions et ne sont donc pas des permutations valides. Lorsqu’il n’y a plus de permutation, l’iterateur lève une exception <code>StopIteration</code>.
</ol>

<aside>Le module <code>itertools</code> a toutes sortes de trucs amusants.</aside>

<p>La fonction <code>permutations()</code> ne demande pas nécessairement une liste. Cela peut être n’importe quelle suite&nbsp;&mdash;&nbsp;y compris une chaine.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import itertools</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>perms = itertools.permutations('ABC', 3)</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<a><samp class=pp>('A', 'B', 'C')</samp>                               <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('A', 'C', 'B')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('B', 'A', 'C')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('B', 'C', 'A')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('C', 'A', 'B')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('C', 'B', 'A')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
StopIteration</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.permutations('ABC', 3))</kbd>    <span class=u>&#x2462;</span></a>
<samp class=pp>[('A', 'B', 'C'), ('A', 'C', 'B'),
 ('B', 'A', 'C'), ('B', 'C', 'A'),
 ('C', 'A', 'B'), ('C', 'B', 'A')]</samp></pre>
<ol>
<li>Une chaine est juste une suite de caractères. Dans le cas de la recherche de permutations, la chaine <code>'ABC'</code> est équivalente à la liste <code>['A', 'B', 'C']</code>.
<li>The first permutation of the 3 items <code>['A', 'B', 'C']</code>, taken 3 at a time, is <code>('A', 'B', 'C')</code>. There are five other permutations&nbsp;&mdash;&nbsp;the same three characters in every conceivable order.
<li>Since the <code>permutations()</code> function always returns an iterator, an easy way to debug permutations is to pass that iterator to the built-in <code>list()</code> function to see all the permutations immediately.
</ol>

<p class=a>&#x2042;

<h2 id=more-itertools>Autres Trucs Amusants dans le Module <code>itertools</code></h2>
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import itertools</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.product('ABC', '123'))</kbd>   <span class=u>&#x2460;</span></a>
<samp class=pp>[('A', '1'), ('A', '2'), ('A', '3'), 
 ('B', '1'), ('B', '2'), ('B', '3'), 
 ('C', '1'), ('C', '2'), ('C', '3')]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.combinations('ABC', 2))</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>[('A', 'B'), ('A', 'C'), ('B', 'C')]</samp></pre>
<ol>
<li>La fonction <code>itertools.product()</code> retourne une itérateur contenant le produit cartésien de deux suites.
<li>La fonction <code>itertools.combinations()</code> retourne un itérateur contenant toutes les combinaisons possible de la séquence de longueur donnée. Elle est semblable à la fonction <code>itertools.permutations()</code>, à part qu’elle exclut les combinaisons qui sont des doublons d’autres éléments qui sont dans un ordre différent. Donc, <code>itertools.permutations('ABC', 2)</code> retournera (entre autres) <code>('A', 'B')</code> and <code>('B', 'A')</code>, mais <code>itertools.combinations('ABC', 2)</code> ne retournera pas <code>('B', 'A')</code> puisque c’est un doublon de <code>('A', 'B')</code> dans un ordre différent.
</ol>

<p class=d>[<a href=examples/favorite-people.txt>télécharger <code>favorite-people.txt</code></a>]
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>names = list(open('examples/favorite-people.txt', encoding='utf-8'))</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>names</kbd>
<samp class=pp>['Dora\n', 'Ethan\n', 'Wesley\n', 'John\n', 'Anne\n',
'Mike\n', 'Chris\n', 'Sarah\n', 'Alex\n', 'Lizzie\n']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>names = [name.rstrip() for name in names]</kbd>                             <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>names</kbd>
<samp class=pp>['Dora', 'Ethan', 'Wesley', 'John', 'Anne',
'Mike', 'Chris', 'Sarah', 'Alex', 'Lizzie']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>names = sorted(names)</kbd>                                                 <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>names</kbd>
<samp class=pp>['Alex', 'Anne', 'Chris', 'Dora', 'Ethan',
'John', 'Lizzie', 'Mike', 'Sarah', 'Wesley']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>names = sorted(names, key=len)</kbd>                                        <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>names</kbd>
<samp class=pp>['Alex', 'Anne', 'Dora', 'John', 'Mike',
'Chris', 'Ethan', 'Sarah', 'Lizzie', 'Wesley']</samp></pre>
<ol>
<li>Cette expression idiomatique retourne une liste des lignes d’un fichier texte.
<li>Malheureusement (pour cet exemple), l’expression <code>list(open(<var>filename</var>))</code> inclut aussi un retour chariot à la fin de chaque ligne. Cette liste par compréhension utilise la méthode <code>rstrip()</code> des chaine pour retirer les espaces blanches à la fin de chaque ligne. (Les chaines ont aussi une méthode <code>lstrip()</code> pour retirer les espaces blanches au début, et <code>strip()</code> qui fait les deux.)
<li>La fonction <code>sorted()</code> prend une liste et la renvoie triée. Par défaut, elle est triée par ordre alphabétique.
<li>Mais la fonction <code>sorted()</code> peut aussi prendre une fonction <em>via</em> le paramètre <var>key</var>, et elle trie en utilisant cette clé. Dans ce cas, la fonction de tri est <code>len()</code>, donc elle trie par <code>len(<var>chaque élément</var>)</code>. Les noms les plus court d’abord, puis les plus longs.
</ol>

<p>Qu’est-ce que cela a à voir avec le module <code>itertools</code>&nbsp;? Je suis heureux que vous vous posiez la question.

<pre class=screen>
&hellip; continuons le shell interactif précédent&hellip;
<samp class=p>>>> </samp><kbd class=pp>import itertools</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>groups = itertools.groupby(names, len)</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>groups</kbd>
<samp class=pp>&lt;itertools.groupby object at 0x00BB20C0></samp>
<samp class=p>>>> </samp><kbd class=pp>list(groups)</kbd>
<samp class=pp>[(4, &lt;itertools._grouper object at 0x00BA8BF0>),
 (5, &lt;itertools._grouper object at 0x00BB4050>),
 (6, &lt;itertools._grouper object at 0x00BB4030>)]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>groups = itertools.groupby(names, len)</kbd>   <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>for name_length, name_iter in groups:</kbd>    <span class=u>&#x2462;</span></a>
<samp class=p>... </samp><kbd class=pp>    print('Noms à {0:d} lettres :'.format(name_length))</kbd>
<samp class=p>... </samp><kbd class=pp>    for name in name_iter:</kbd>
<samp class=p>... </samp><kbd class=pp>        print(name)</kbd>
<samp class=p>... </samp>
<samp>Noms à 4 lettres :
Alex
Anne
Dora
John
Mike
Noms à 5 lettres :
Chris
Ethan
Sarah
Noms à 6 lettres :
Lizzie
Wesley</samp></pre>
<ol>
<li>La fonction <code>itertools.groupby()</code> prend une suite et une fonction clé, et retourne un itérateur qui engendre des paires. Chaque paire contient le résultat de <code>fonction_clef(<var>chaque élément</var>)</code> et un autre itérateur contenant tous les éléments qui partageaient ce résultat de la clé.
<li>Appeler la fonction <code>list()</code> a «&nbsp;épuisé&nbsp;» l’itérateur, c’est-à-dire que vous avez déjà engendré chaque élément dans l’itérateur pour faire une liste. Il n’y a pas de bouton de «&nbsp;remise à zéro&nbsp;» d’un itérateur, vous ne pouvez juste pas le relancer une fois que vous l’avez épuisé. Si vous voulez à nouveau le parcourir (par exemple, dans la boucle <code>for</code> suivante), vous devez à nouveau appeler <code>itertools.groupby()</code> pour créer un nouvel itérateur.
<li>Dans cet exemple, étant donné une liste de noms <em>déjà triés par longueur</em>, <code>itertools.groupby(name, len)</code> mettera tous les noms de quatre lettres dans un itérateur, ceux de cinq lettres dans un autre, etc. La fonction <code>groupby()</code> est complètement générique&nbsp;; elle peut grouper les chaines par première lettre, des nombres par leur nombre de facteur, ou n’importe quelle autre fonction de clé à laquelle vous pouvez penser.
</ol>
<!-- YO DAWG, WE HEARD YOU LIKE LOOPING, SO WE PUT AN ITERATOR IN YOUR ITERATOR SO YOU CAN LOOP WHILE YOU LOOP. -->

<blockquote class=note>
<p><span class=u>&#x261E;</span>La fonction <code>itertools.groupby()</code> ne fonctionne qu’avec une séquence d’entrée qui est déjà triée avec avec la fonction de regroupement. Dans l’exemple précédent, vous avez groupé une liste de noms avec la fonction <code>len()</code>. Cela fonctionnait seulement parce que la liste d’entrée était déjà triée par longueur.
</blockquote>

<p>Regardez-vous attentivement&nbsp;?
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>list(range(0, 3))</kbd>
<samp class=pp>[0, 1, 2]</samp>
<samp class=p>>>> </samp><kbd class=pp>list(range(10, 13))</kbd>
<samp class=pp>[10, 11, 12]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.chain(range(0, 3), range(10, 13)))</kbd>        <span class=u>&#x2460;</span></a>
<samp class=pp>[0, 1, 2, 10, 11, 12]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(zip(range(0, 3), range(10, 13)))</kbd>                    <span class=u>&#x2461;</span></a>
<samp class=pp>[(0, 10), (1, 11), (2, 12)]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(zip(range(0, 3), range(10, 14)))</kbd>                    <span class=u>&#x2462;</span></a>
<samp class=pp>[(0, 10), (1, 11), (2, 12)]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.zip_longest(range(0, 3), range(10, 14)))</kbd>  <span class=u>&#x2463;</span></a>
<samp class=pp>[(0, 10), (1, 11), (2, 12), (None, 13)]</samp></pre>
<ol>
<li>La fonction <code>itertools.chain()</code> prend deux itérateurs et retourne un itérateur qui contient tous les éléments du premier, suivis par tous les éléments du second. (À vrai dire, elle peut prendre n’importe quelle quantité d’itérateur, et les chainer dans l’ordre dans lequel ils ont été passés à la fonction.)
<li>La fonction <code>zip()</code> fait quelque chose d’assez prosaïque qui se trouve être extrêmement utile&nbsp;: elle prend n’importe quel nombre de suites et retourne un itérateur qui onvitnent des n-uplets&nbsp;: d’abord les premiers éléments de chaque séquence, puis les seconds de chacune, puis les troisièmes, etc.
<li>La fonction <code>zip()</code> s’arrête à la fin de la plus courte des séquences. <code>range(10, 14)</code> a quatre éléments (10, 11, 12, et 13), mais <code>range(0, 3)</code> n’en a que trois, donc la fonction <code>zip()</code> retourne un itérateur de trois éléments.
<li>À l’inverse, la fonction <code>itertools.zip_longest()</code> s’arrête à la fin de la <em>plus longue</em> suite, en insérant des valeurs <code>None</code> à la place des éléments après la fin des plus courtes suites.
</ol>

<p id=dict-zip>D’accord, tout cela était très intéressant, mais quel est le rapport avec le résolveur d’alphamétiques&nbsp;? Le voici&nbsp;:

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>characters = ('S', 'M', 'E', 'D', 'O', 'N', 'R', 'Y')</kbd>
<samp class=p>>>> </samp><kbd class=pp>guess = ('1', '2', '0', '3', '4', '5', '6', '7')</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>tuple(zip(characters, guess))</kbd>  <span class=u>&#x2460;</span></a>
<samp class=pp>(('S', '1'), ('M', '2'), ('E', '0'), ('D', '3'),
 ('O', '4'), ('N', '5'), ('R', '6'), ('Y', '7'))</samp>
<a><samp class=p>>>> </samp><kbd class=pp>dict(zip(characters, guess))</kbd>   <span class=u>&#x2461;</span></a>
<samp class=pp>{'E': '0', 'D': '3', 'M': '2', 'O': '4',
 'N': '5', 'S': '1', 'R': '6', 'Y': '7'}</samp></pre>
<ol>
<li>Étant donné une liste de lettrres et une liste de chiffre (chacun-e représené-e comme une chaine à un caractère), la fonction <code>zip</code> retournera un appariement de lettres et de chiffres, dans l’ordre.
<li>En quoi est-ce génial&nbsp;? Parce que cette structure de données se trouve être exactement celle à passer à la fonction <code>dict()</code> pour créer un dictionnaire qui utilise les lettres comme clé et leur value associée comme valeurs. (Ce n’est pas la seule façon de le faire, bien sûr. Vous pouvez utiliser un <a href=comprehensions.html#dictionarycomprehension>dictionnaire par compréhension</a> pour créer un dictionnaire directement.) Même si la représentation affichée du dictionnaire liste les paires dans un ordre différent (les dictionnaires n’ont par d’«&nbs;ordre&nbsp;» en eux-mêmes), vous pouvez voir que chaque lettre est associée au chiffre, en se basant sur l’ordre des suites <var>characters</var> et <var>guess</var> originales.
</ol>

<p id=guess>Le résolveur d’alphamétiques utilise cette technique pour créer un dictionnaire qui fait correspondre à chaque lettre un chiffre de la solution, pour chaque solution possible.

<pre class='nd pp'><code>characters = tuple(ord(c) for c in sorted_characters)
digits = tuple(ord(c) for c in '0123456789')
...
for guess in itertools.permutations(digits, len(characters)):
    ...
<mark>    equation = puzzle.translate(dict(zip(characters, guess)))</mark></code></pre>

<p>Mais quelle est cette méthode <code>translate()</code>&nbsp;? Ah, maintenant vous arrivez à la partie amusante.

<p class=a>&#x2042;

<h2 id=string-translate>A New Kind Of String Manipulation</h2>

<p>Python strings have many methods. You learned about some of those methods in <a href=strings.html>the Strings chapter</a>: <code>lower()</code>, <code>count()</code>, and <code>format()</code>. Now I want to introduce you to a powerful but little-known string manipulation technique: the <code>translate()</code> method.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>translation_table = {ord('A'): ord('O')}</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>translation_table</kbd>                         <span class=u>&#x2461;</span></a>
<samp class=pp>{65: 79}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>'MARK'.translate(translation_table)</kbd>       <span class=u>&#x2462;</span></a>
<samp class=pp>'MORK'</samp></pre>
<ol>
<li>String translation starts with a translation table, which is just a dictionary that maps one character to another. Actually, &#8220;character&#8221; is incorrect&nbsp;&mdash;&nbsp;the translation table really maps one <em>byte</em> to another.
<li>Remember, bytes in Python 3 are integers. The <code>ord()</code> function returns the <abbr>ASCII</abbr> value of a character, which, in the case of A&ndash;Z, is always a byte from 65 to 90.
<li>The <code>translate()</code> method on a string takes a translation table and runs the string through it. That is, it replaces all occurrences of the keys of the translation table with the corresponding values. In this case, &#8220;translating&#8221; <code>MARK</code> to <code>MORK</code>.
</ol>

<aside>Now you&#8217;re getting to the <em>really</em> fun part.</aside>

<p>What does this have to do with solving alphametic puzzles? As it turns out, everything.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>characters = tuple(ord(c) for c in 'SMEDONRY')</kbd>       <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>characters</kbd>
<samp class=pp>(83, 77, 69, 68, 79, 78, 82, 89)</samp>
<a><samp class=p>>>> </samp><kbd class=pp>guess = tuple(ord(c) for c in '91570682')</kbd>            <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>guess</kbd>
<samp class=pp>(57, 49, 53, 55, 48, 54, 56, 50)</samp>
<a><samp class=p>>>> </samp><kbd class=pp>translation_table = dict(zip(characters, guess))</kbd>     <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>translation_table</kbd>
<samp class=pp>{68: 55, 69: 53, 77: 49, 78: 54, 79: 48, 82: 56, 83: 57, 89: 50}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>'SEND + MORE == MONEY'.translate(translation_table)</kbd>  <span class=u>&#x2463;</span></a>
<samp class=pp>'9567 + 1085 == 10652'</samp></pre>
<ol>
<li>Using a <a href=#generator-expressions>generator expression</a>, we quickly compute the byte values for each character in a string. <var>characters</var> is an example of the value of <var>sorted_characters</var> in the <code>alphametics.solve()</code> function.
<li>Using another generator expression, we quickly compute the byte values for each digit in this string. The result, <var>guess</var>, is of the form <a href=#guess>returned by the <code>itertools.permutations()</code> function</a> in the <code>alphametics.solve()</code> function.
<li>This translation table is generated by <a href=#dict-zip>zipping <var>characters</var> and <var>guess</var> together</a> and building a dictionary from the resulting sequence of pairs. This is exactly what the <code>alphametics.solve()</code> function does inside the <code>for</code> loop.
<li>Finally, we pass this translation table to the <code>translate()</code> method of the original puzzle string. This converts each letter in the string to the corresponding digit (based on the letters in <var>characters</var> and the digits in <var>guess</var>). The result is a valid Python expression, as a string.
</ol>

<p>That&#8217;s pretty impressive. But what can you do with a string that happens to be a valid Python expression?

<p class=a>&#x2042;

<h2 id=eval>Evaluating Arbitrary Strings As Python Expressions</h2>

<p>This is the final piece of the puzzle (or rather, the final piece of the puzzle solver). After all that fancy string manipulation, we&#8217;re left with a string like <code>'9567 + 1085 == 10652'</code>. But that&#8217;s a string, and what good is a string? Enter <code>eval()</code>, the universal Python evaluation tool.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>eval('1 + 1 == 2')</kbd>
<samp class=pp>True</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('1 + 1 == 3')</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('9567 + 1085 == 10652')</kbd>
<samp class=pp>True</samp></pre>

<p>But wait, there&#8217;s more! The <code>eval()</code> function isn&#8217;t limited to boolean expressions. It can handle <em>any</em> Python expression and returns <em>any</em> datatype.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>eval('"A" + "B"')</kbd>
<samp class=pp>'AB'</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('"MARK".translate({65: 79})')</kbd>
<samp class=pp>'MORK'</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('"AAAAA".count("A")')</kbd>
<samp class=pp>5</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('["*"] * 5')</kbd>
<samp class=pp>['*', '*', '*', '*', '*']</samp></pre>

<p>But wait, that&#8217;s not all!

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>x = 5</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("x * 5")</kbd>         <span class=u>&#x2460;</span></a>
<samp class=pp>25</samp>
<a><samp class=p>>>> </samp><kbd class=pp>eval("pow(x, 2)")</kbd>     <span class=u>&#x2461;</span></a>
<samp class=pp>25</samp>
<samp class=p>>>> </samp><kbd class=pp>import math</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("math.sqrt(x)")</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>2.2360679774997898</samp></pre>
<ol>
<li>The expression that <code>eval()</code> takes can reference global variables defined outside the <code>eval()</code>. If called within a function, it can reference local variables too.
<li>And functions.
<li>And modules.
</ol>

<p>Hey, wait a minute&hellip;

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import subprocess</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("subprocess.getoutput('ls ~')")</kbd>                  <span class=u>&#x2460;</span></a>
<samp class=pp>'Desktop         Library         Pictures \
 Documents       Movies          Public   \
 Music           Sites'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>eval("subprocess.getoutput('rm /some/random/file')")</kbd>  <span class=u>&#x2461;</span></a></pre>
<ol>
<li>The <code>subprocess</code> module allows you to run arbitrary shell commands and get the result as a Python string.
<li>Arbitrary shell commands can have permanent consequences.
</ol>

<p>It&#8217;s even worse than that, because there&#8217;s a global <code>__import__()</code> function that takes a module name as a string, imports the module, and returns a reference to it. Combined with the power of <code>eval()</code>, you can construct a single expression that will wipe out all your files:

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>eval("__import__('subprocess').getoutput('rm /some/random/file')")</kbd>  <span class=u>&#x2460;</span></a></pre>
<ol>
<li>Now imagine the output of <code>'rm -rf ~'</code>. Actually there wouldn&#8217;t be any output, but you wouldn&#8217;t have any files left either.
</ol>

<p class=xxxl>eval() is EVIL

<p>Well, the evil part is evaluating arbitrary expressions from untrusted sources. You should only use <code>eval()</code> on trusted input. Of course, the trick is figuring out what&#8217;s &#8220;trusted.&#8221; But here&#8217;s something I know for certain: you should <b>NOT</b> take this alphametics solver and put it on the internet as a fun little web service. Don&#8217;t make the mistake of thinking, &#8220;Gosh, the function does a lot of string manipulation before getting a string to evaluate; <em>I can&#8217;t imagine</em> how someone could exploit that.&#8221; Someone <b>WILL</b> figure out how to sneak nasty executable code past all that string manipulation (<a href=http://www.securityfocus.com/blogs/746>stranger things have happened</a>), and then you can kiss your server goodbye.

<p>But surely there&#8217;s <em>some</em> way to evaluate expressions safely? To put <code>eval()</code> in a sandbox where it can&#8217;t access or harm the outside world? Well, yes and no.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>x = 5</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("x * 5", {}, {})</kbd>               <span class=u>&#x2460;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 1, in &lt;module>
NameError: name 'x' is not defined</samp>
<a><samp class=p>>>> </samp><kbd class=pp>eval("x * 5", {"x": x}, {})</kbd>         <span class=u>&#x2461;</span></a>
<samp class=p>25</samp>
<samp class=p>>>> </samp><kbd class=pp>import math</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("math.sqrt(x)", {"x": x}, {})</kbd>  <span class=u>&#x2462;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 1, in &lt;module>
NameError: name 'math' is not defined</samp></pre>
<ol>
<li>The second and third parameters passed to the <code>eval()</code> function act as the global and local namespaces for evaluating the expression. In this case, they are both empty, which means that when the string <code>"x * 5"</code> is evaluated, there is no reference to <var>x</var> in either the global or local namespace, so <code>eval()</code> throws an exception.
<li>You can selectively include specific values in the global namespace by listing them individually. Then those&nbsp;&mdash;&nbsp;and only those&nbsp;&mdash;&nbsp;variables will be available during evaluation.
<li>Even though you just imported the <code>math</code> module, you didn&#8217;t include it in the namespace passed to the <code>eval()</code> function, so the evaluation failed.
</ol>

<p>Gee, that was easy. Lemme make an alphametics web service now!

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>eval("pow(5, 2)", {}, {})</kbd>                   <span class=u>&#x2460;</span></a>
<samp class=pp>25</samp>
<a><samp class=p>>>> </samp><kbd class=pp>eval("__import__('math').sqrt(5)", {}, {})</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>2.2360679774997898</samp></pre>
<ol>
<li>Even though you&#8217;ve passed empty dictionaries for the global and local namespaces, all of Python&#8217;s built-in functions are still available during evaluation. So <code>pow(5, 2)</code> works, because <code>5</code> and <code>2</code> are literals, and <code>pow()</code> is a built-in function.
<li>Unfortunately (and if you don&#8217;t see why it&#8217;s unfortunate, read on), the <code>__import__()</code> function is also a built-in function, so it works too.
</ol>

<p>Yeah, that means you can still do nasty things, even if you explicitly set the global and local namespaces to empty dictionaries when calling <code>eval()</code>:

<pre class='nd screen'><samp class=p>>>> </samp><kbd class=pp>eval("__import__('subprocess').getoutput('rm /some/random/file')", {}, {})</kbd></pre>

<p>Oops. I&#8217;m glad I didn&#8217;t make that alphametics web service. Is there <em>any</em> way to use <code>eval()</code> safely? Well, yes and no.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>eval("__import__('math').sqrt(5)",</kbd>
<a><samp class=p>... </samp><kbd class=pp>    {"__builtins__":None}, {})</kbd>          <span class=u>&#x2460;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 1, in &lt;module>
NameError: name '__import__' is not defined</samp>
<samp class=p>>>> </samp><kbd class=pp>eval("__import__('subprocess').getoutput('rm -rf /')",</kbd>
<a><samp class=p>... </samp><kbd class=pp>    {"__builtins__":None}, {})</kbd>          <span class=u>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 1, in &lt;module>
NameError: name '__import__' is not defined</samp></pre>
<ol>
<li>To evaluate untrusted expressions safely, you need to define a global namespace dictionary that maps <code>"__builtins__"</code> to <code>None</code>, the Python null value. Internally, the &#8220;built-in&#8221; functions are contained within a pseudo-module called <code>"__builtins__"</code>. This pseudo-module (<i>i.e.</i> the set of built-in functions) is made available to evaluated expressions unless you explicitly override it.
<li>Be sure you&#8217;ve overridden <code>__builtins__</code>. Not <code>__builtin__</code>, <code>__built-ins__</code>, or some other variation that will work just fine but expose you to catastrophic risks.
</ol>

<p>So <code>eval()</code> is safe now? Well, yes and no.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>eval("2 ** 2147483647",</kbd>
<a><samp class=p>... </samp><kbd class=pp>    {"__builtins__":None}, {})</kbd>          <span class=u>&#x2460;</span></a>
</pre>
<ol>
<li>Even without access to <code>__builtins__</code>, you can still launch a denial-of-service attack. For example, trying to raise <code>2</code> to the <code>2147483647</code><sup>th</sup> power will spike your server&#8217;s <abbr>CPU</abbr> utilization to 100% for quite some time. (If you&#8217;re trying this in the interactive shell, press <kbd>Ctrl-C</kbd> a few times to break out of it.) Technically this expression <em>will</em> return a value eventually, but in the meantime your server will be doing a whole lot of nothing.
</ol>

<p>In the end, it <em>is</em> possible to safely evaluate untrusted Python expressions, for some definition of &#8220;safe&#8221; that turns out not to be terribly useful in real life. It&#8217;s fine if you&#8217;re just playing around, and it&#8217;s fine if you only ever pass it trusted input. But anything else is just asking for trouble.

<p class=a>&#x2042;

<h2 id=alphametics-finale>Putting It All Together</h2>

<p>To recap: this program solves alphametic puzzles by brute force, <i>i.e.</i> through an exhaustive search of all possible solutions. To do this, it&hellip;

<ol>
<li><a href=#re-findall>Finds all the letters in the puzzle</a> with the <code>re.findall()</code> function
<li><a href=#unique-items>Find all the <em>unique</em> letters in the puzzle</a> with sets and the <code>set()</code> function
<li><a href=#assert>Checks if there are more than 10 unique letters</a> (meaning the puzzle is definitely unsolvable) with an <code>assert</code> statement
<li><a href=#generator-objects>Converts the letters to their ASCII equivalents</a> with a generator object
<li><a href=#permutations>Calculates all the possible solutions</a> with the <code>itertools.permutations()</code> function
<li><a href=#string-translate>Converts each possible solution to a Python expression</a> with the <code>translate()</code> string method
<li><a href=#eval>Tests each possible solution by evaluating the Python expression</a> with the <code>eval()</code> function
<li>Returns the first solution that evaluates to <code>True</code>
</ol>

<p>&hellip;in just 14 lines of code.

<p class=a>&#x2042;

<h2 id=furtherreading>Further Reading</h2>

<ul>
<li><a href=http://docs.python.org/3.1/library/itertools.html><code>itertools</code> module</a>
<li><a href=http://www.doughellmann.com/PyMOTW/itertools/><code>itertools</code>&nbsp;&mdash;&nbsp;Iterator functions for efficient looping</a>
<li><a href=http://blip.tv/file/1947373/>Watch Raymond Hettinger&#8217;s &#8220;Easy AI with Python&#8221; talk</a> at PyCon 2009
<li><a href=http://code.activestate.com/recipes/576615/>Recipe 576615: Alphametics solver</a>, Raymond Hettinger&#8217;s original alphametics solver for Python 2
<li><a href=http://code.activestate.com/recipes/users/178123/>More of Raymond Hettinger&#8217;s recipes</a> in the ActiveState Code repository
<li><a href=http://en.wikipedia.org/wiki/Verbal_arithmetic>Alphametics on Wikipedia</a>
<li><a href=http://www.tkcs-collins.com/truman/alphamet/index.shtml>Alphametics Index</a>, including <a href=http://www.tkcs-collins.com/truman/alphamet/alphamet.shtml>lots of puzzles</a> and <a href=http://www.tkcs-collins.com/truman/alphamet/alpha_gen.shtml>a generator to make your own</a>
</ul>

<p>Many thanks to Raymond Hettinger for agreeing to relicense his code so I could port it to Python 3 and use it as the basis for this chapter.

<p class=v><a href=iterators.html rel=prev title='back to &#8220;Classes &amp; Iterators&#8221;'><span class=u>&#x261C;</span></a> <a href=unit-testing.html rel=next title='onward to &#8220;Unit Testing&#8221;'><span class=u>&#x261E;</span></a>

<p class=c>&copy; 2001&ndash;11 <a href=about.html>Mark Pilgrim</a>
<script src=j/jquery.js></script>
<script src=j/prettify.js></script>
<script src=j/dip3.js></script>
