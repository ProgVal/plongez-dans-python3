---
title: Refactorisation
status: En cours
permalink: refactoring.html
---
<!DOCTYPE html>
<meta charset=utf-8>
<title>Refactorisation - Plongez dans Python 3</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<style>
body{counter-reset:h1 10}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta name=viewport content='initial-scale=1.0'>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input type=search name=q size=25 placeholder="powered by Google&trade;">&nbsp;<input type=submit name=root value=Search></div></form>
<p>Vous êtes ici&nbsp;: <a href=index.html>Home</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#refactoring>Plongez dans Python 3</a> <span class=u>&#8227;</span>
<p id=level>Niveau de difficulté&nbsp;: <span class=u title=advanced>&#x2666;&#x2666;&#x2666;&#x2666;&#x2662;</span>
<h1>Refactoring</h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span> After one has played a vast quantity of notes and more notes, it is simplicity that emerges as the crowning reward of art. <span class=u>&#x275E;</span><br>&mdash; <a href=http://en.wikiquote.org/wiki/Fr%C3%A9d%C3%A9ric_Chopin>Fr&eacute;d&eacute;ric Chopin</a>
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Plongée</h2>
<p class=f>Qu’on le veuille ou non, les bogues arrivent. Malgré tous vos efforts pour écrire des <a href=unit-testing.html>tests unitaires</a> compréhensifs, les bogues arrivent. Qu’est-ce que je veux dire par « bogue » ? Un bogue est un test que vous n’avez pas encore écrit.

<pre class=screen><samp class=p>>>> </samp><kbd class=pp>import roman7</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>roman7.from_roman('')</kbd> <span class=u>&#x2460;</span></a>
<samp class=pp>0</samp></pre>
<ol>
<li>C’est un bogue. Une chaine de caractère vide devrait lever une exception <code>InvalidRomanNumeralError</code>, comme n’importe quelle autre chaine qui ne représente pas un nombre romain valide.
</ol>

<p>Après avoir reproduit le bogue, et avant de le fixer, vous devez écrire un cas de test qui échoue, illustrant ainsi le bogue.

<pre class=pp><code>class FromRomanBadInput(unittest.TestCase):  
    .
    .
    .
    def testBlank(self):
        '''from_roman devrait échouer avec une chaine vide'''
<a>        self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, '') <span class=u>&#x2460;</span></a></code></pre>
<ol>
<li>Ce qui se déroule ici est assez simple. Appelez <code>from_roman()</code> avec une chaine vide et assurez-vous qu’il lève une exception <code>InvalidRomanNumeralError</code>. La partie difficile était de trouver le bogue : ceci étant fait, écrire un test est facile.
</ol>

<p>Puisque votre code a un bogue, et que vous avez un cas de test pour ce bogue, le cas de test va échouer :
<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest8.py -v</kbd>
<samp>from_roman should fail with blank string ... FAIL
from_roman should fail with malformed antecedents ... ok
from_roman should fail with repeated pairs of numerals ... ok
from_roman should fail with too many repeated numerals ... ok
from_roman should give known result with known input ... ok
to_roman should give known result with known input ... ok
from_roman(to_roman(n))==n for all n ... ok
to_roman should fail with negative input ... ok
to_roman should fail with non-integer input ... ok
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... ok

======================================================================
FAIL: from_roman should fail with blank string
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest8.py", line 117, in test_blank
    self.assertRaises(roman8.InvalidRomanNumeralError, roman8.from_roman, '')
<mark>AssertionError: InvalidRomanNumeralError not raised by from_roman</mark>

----------------------------------------------------------------------
Ran 11 tests in 0.171s

FAILED (failures=1)</samp></pre>

<p><em>Maintenant</em>, vous pouvez fixer le bogue.

<pre class=pp><code>def from_roman(s):
    '''convertit un nombre romain en entier'''
<a>    if not s:                                                                  <span class=u>&#x2460;</span></a>
        raise InvalidRomanNumeralError('Input can not be blank')
    if not re.search(romanNumeralPattern, s):
<a>        raise InvalidRomanNumeralError('Invalid Roman numeral: {}'.format(s))  <span class=u>&#x2461;</span></a>

    result = 0
    index = 0
    for numeral, integer in romanNumeralMap:
        while s[index:index+len(numeral)] == numeral:
            result += integer
            index += len(numeral)
    return result</code></pre>
<ol>
<li>Seules deux lignes de code sont requises : une vérification explicite pour une chaine vide, et une déclaration <code>raise</code>.
<li>Je ne pense pas l’avoir déjà mentionné dans ce livre, utilisons donc ceci comme dernière leçon dans le <a href=strings.html#formatting-strings>formatage de chaîne</a>. À partir de Python 3.1, vous pouvez ignorer les chiffres lors de l’utilisation des index de position dans une spécification de format. Autrement dit, au lieu d’utiliser le spécificateur de format <code>{0}</code> pour désigner le premier paramètre du format de <code>format()</code>, vous pouvez simplement utiliser <code>{}</code> et Python va remplir l’indice de position convenable pour vous. Cela fonctionne pour n’importe quel nombre d’arguments : le premier <code>{}</code> est équivalent à <code>{0}</code>, le deuxième <code>{}</code> à <code>{1}</code>, et ainsi de suite.
</ol>

<pre class='screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest8.py -v</kbd>
<a><samp>from_roman should fail with blank string ... ok</samp>  <span class=u>&#x2460;</span></a>
<samp>from_roman should fail with malformed antecedents ... ok
from_roman should fail with repeated pairs of numerals ... ok
from_roman should fail with too many repeated numerals ... ok
from_roman should give known result with known input ... ok
to_roman should give known result with known input ... ok
from_roman(to_roman(n))==n for all n ... ok
to_roman should fail with negative input ... ok
to_roman should fail with non-integer input ... ok
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... ok

----------------------------------------------------------------------
Ran 11 tests in 0.156s
</samp>
<a><samp>OK</samp>  <span class=u>&#x2461;</span></a></pre>
<ol>
<li>Le test de la chaine vide passe maintenant, donc le bug est fixé.
<li>Tous les autres tests passent aussi, ce qui signifie que la résolution du bogue n’a pas cassé quelque chose d’autre. Arrêtez de coder.
</ol>

<p>Coder de cette manière ne rend pas la résolution des bogues plus facile. Des bogues simples (comme celui-ci) nécessitent des tests simples ; des bogues plus complexes nécessiteront des tests plus complexes. Dans un environnement centré sur les tests, il pourrait <em>sembler</em> que la résolution du bogue prend plus de temps, étant donné que vous devez naviguer dans le code pour comprendre exactement quel est le bogue (pour écrire le scénario de test), puis fixer le bogue lui-même. Ensuite, si le test ne passe pas, vous devez trouver si la modification du code est fausse ou si le test lui-même est bogué. Cependant, à long terme, ce va-et-vient entre le code de test et le code testé est rentable, car il est plus probable que les bogues soient corrigés correctement dès la première fois. En outre, puisque vous pouvez facilement ré-exécuter <em>tous</em> les tests en plus du nouveau, vous êtes beaucoup moins susceptible de casser l’ancien code en corrigeant le nouveau code. Le test unitaire d’aujourd'hui est le test de régression de demain.

<p class=a>&#x2042;

<h2 id=changing-requirements>Supporter les exigences de changements</h2>
<p>Malgré vos meilleurs efforts pour plaquer vos clients au sol et extraire les exigences exactes d’eux sous peine de vilaines choses horribles impliquant des ciseaux et de la cire chaude, les spécifications vont changer. La plupart des clients ne savent pas ce qu’ils veulent jusqu’à ce qu’ils le voient, et même s’ils le savent, ils ne savent pas vraiment comment exprimer ce qu’ils veulent avec suffisamment de précision pour être utile. Et même s’ils le savent, ils voudront plus dans la prochaine version de toute façon. Soyez donc prêt à mettre à jour vos tests, car les spécifications changent.

<p>Supposons, par exemple, que vous vouliez étendre la plage des fonctions de conversion des chiffres romains. Normalement, aucun caractère dans un chiffre romain ne peut être répété plus de trois fois dans une rangée. Mais les Romains étaient prêts à faire une exception à cette règle en ayant 4 caractères <code>M</code> sur une ligne pour représenter <code>4000</code>. Si vous faites ce changement, vous serez en mesure d’élargir la gamme des nombres convertibles de <code>1..3999</code> à <code>1..4999</code>. Mais d’abord, vous avez besoin de faire quelques changements à vos tests.

<p class=d>[<a href=examples/roman8.py>download <code>roman8.py</code></a>]
<pre class=pp><code>class KnownValues(unittest.TestCase):
    known_values = ( (1, 'I'),
                      .
                      .
                      .
                     (3999, 'MMMCMXCIX'),
<a>                     (4000, 'MMMM'),                                      <span class=u>&#x2460;</span></a>
                     (4500, 'MMMMD'),
                     (4888, 'MMMMDCCCLXXXVIII'),
                     (4999, 'MMMMCMXCIX') )

class ToRomanBadInput(unittest.TestCase):
    def test_too_large(self):
        '''to_roman should fail with large input'''
<a>        self.assertRaises(roman8.OutOfRangeError, roman8.to_roman, 5000)  <span class=u>&#x2461;</span></a>

    .
    .
    .

class FromRomanBadInput(unittest.TestCase):
    def test_too_many_repeated_numerals(self):
        '''from_roman should fail with too many repeated numerals'''
<a>        for s in ('MMMMM', 'DD', 'CCCC', 'LL', 'XXXX', 'VV', 'IIII'):     <span class=u>&#x2462;</span></a>
            self.assertRaises(roman8.InvalidRomanNumeralError, roman8.from_roman, s)

    .
    .
    .

class RoundtripCheck(unittest.TestCase):
    def test_roundtrip(self):
        '''from_roman(to_roman(n))==n for all n'''
<a>        for integer in range(1, 5000):                                    <span class=u>&#x2463;</span></a>
            numeral = roman8.to_roman(integer)
            result = roman8.from_roman(numeral)
            self.assertEqual(integer, result)</code></pre>
<ol>
<li>Les valeurs connues existantes ne changent pas (ce sont toujours des valeurs raisonnables à tester), mais vous avez besoin d’en ajouter quelques unes dans la plage <code>4000</code>. Ici, j’ai inclus <code>4000</code> (la plus courte), <code>4500</code> (la seconde plus courte), <code>4888</code> (la plus longue), et <code>4999</code> (la plus grande).
<li>La définition de « grande entrée » a changé. Ce test appelait <code>to_roman()</code> avec <code>4000</code> et attendait une erreur, maintenant que <code>4000-4999</code> sont des valeurs correctes, vous devez repousser la limite à <code>5000</code>.
<li>La définition de « trop de chiffres répétés » a également changé. Ce test appelait <code>from_roman()</code> avec <code>'MMMM'</code> et attendait une erreur. Maintenant que <code>MMMM</code> est considéré comme un nombre romain valide, vous avez besoin de repousser ce test jusqu’à <code>'MMMMM'</code>.
<li>Le test d’intégrité parcourt chaque numéro dans l’intervalle, à partir de <code>1</code> jusque <code>3999</code>. Depuis, la gamme s’est élargie, cette boucle <code>for</code> a besoin d’être mise à jour afin d’aller jusqu’à <code>4999</code>.
</ol>

<p>Now your test cases are up to date with the new requirements, but your code is not, so you expect several of the test cases to fail.
<p>Vos cas de test sont à jour avec les nouvelles exigences, mais votre code ne l’est pas, de sorte que vous attendez de plusieurs tests qu’ils échouent.

<pre class='screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest9.py -v</kbd>
<samp>from_roman should fail with blank string ... ok
from_roman should fail with malformed antecedents ... ok
from_roman should fail with non-string input ... ok
from_roman should fail with repeated pairs of numerals ... ok
from_roman should fail with too many repeated numerals ... ok
<a>from_roman should give known result with known input ... ERROR          <span class=u>&#x2460;</span></a>
<a>to_roman should give known result with known input ... ERROR            <span class=u>&#x2461;</span></a>
<a>from_roman(to_roman(n))==n for all n ... ERROR                          <span class=u>&#x2462;</span></a>
to_roman should fail with negative input ... ok
to_roman should fail with non-integer input ... ok
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... ok

======================================================================
ERROR: from_roman should give known result with known input
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest9.py", line 82, in test_from_roman_known_values
    result = roman9.from_roman(numeral)
  File "C:\home\diveintopython3\examples\roman9.py", line 60, in from_roman
    raise InvalidRomanNumeralError('Invalid Roman numeral: {0}'.format(s))
<mark>roman9.InvalidRomanNumeralError: Invalid Roman numeral: MMMM</mark>

======================================================================
ERROR: to_roman should give known result with known input
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest9.py", line 76, in test_to_roman_known_values
    result = roman9.to_roman(integer)
  File "C:\home\diveintopython3\examples\roman9.py", line 42, in to_roman
    raise OutOfRangeError('number out of range (must be 0..3999)')
<mark>roman9.OutOfRangeError: number out of range (must be 0..3999)</mark>

======================================================================
ERROR: from_roman(to_roman(n))==n for all n
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest9.py", line 131, in testSanity
    numeral = roman9.to_roman(integer)
  File "C:\home\diveintopython3\examples\roman9.py", line 42, in to_roman
    raise OutOfRangeError('number out of range (must be 0..3999)')
<mark>roman9.OutOfRangeError: number out of range (must be 0..3999)</mark>

----------------------------------------------------------------------
Ran 12 tests in 0.171s

FAILED (errors=3)</samp></pre>
<ol>
<li>Le test <code>from_roman()</code> des valeurs connues échoue dès qu’il atteint <code>'MMMM'</code>, car <code>from_roman()</code> pense toujours que c’est un nombre romain invalide.
<li>Le test <code>to_roman()</code> des valeurs connues échoue dès qu’il atteint <code>4000</code>, car <code>to_roman()</code> pense toujours qu’il est en dehors de l’intervalle.
<li>Le test aller-retour échouera également dès qu’il atteindra <code>4000</code>, car <code>to_roman()</code> pense toujours qu’il est en dehors de l’intervalle.
</ol>

<p>Maintenant que vous avez des cas de test qui échouent en raison des nouvelles exigences, vous pouvez penser à fixer le code pour le mettre en conformité avec les scénarios de test. (Lorsque vous commencez à utiliser les tests unitaires, il pourra vous sembler étrange que le code testé ne soit jamais « en avance » sur les cas de test. Même s’il est en retard, vous avez encore du travail à faire, et dès qu’il remplit tous les tests, vous arrêtez de coder. Une fois que vous y serez habitué, vous vous demanderez comment vous avez pu programmer sans tests.)

<p class=d>[<a href=examples/roman9.py>download <code>roman9.py</code></a>]
<pre class=pp><code>roman_numeral_pattern = re.compile('''
    ^                   # beginning of string
<a>    M{0,4}              # thousands - 0 to 4 Ms  <span class=u>&#x2460;</span></a>
    (CM|CD|D?C{0,3})    # hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 Cs),
                        #            or 500-800 (D, followed by 0 to 3 Cs)
    (XC|XL|L?X{0,3})    # tens - 90 (XC), 40 (XL), 0-30 (0 to 3 Xs),
                        #        or 50-80 (L, followed by 0 to 3 Xs)
    (IX|IV|V?I{0,3})    # ones - 9 (IX), 4 (IV), 0-3 (0 to 3 Is),
                        #        or 5-8 (V, followed by 0 to 3 Is)
    $                   # end of string
    ''', re.VERBOSE)

def to_roman(n):
    '''convertit un entier en nombre romain'''
    if not isinstance(n, int):
        raise NotIntegerError('non-integers can not be converted')
<a>    if not (0 &lt; n &lt; 5000):                        <span class=u>&#x2461;</span></a>
        raise OutOfRangeError('number out of range (must be 1..4999)')

    result = ''
    for numeral, integer in roman_numeral_map:
        while n >= integer:
            result += numeral
            n -= integer
    return result

def from_roman(s):
    .
    .
    .</code></pre>
<ol>
<li>Vous n’avez pas besoin d’apporter de modifications à la fonction <code>from_roman()</code> du tout. Le seul changement a apporté se situe dans <var>roman_numeral_pattern</var>. Si vous regardez attentivement, vous remarquerez que j’ai changé le nombre maximal d’option <code>M</code> de <code>3</code> à <code>4</code> dans la première section de l’expression régulière. Cela permettra les équivalents de chiffres romains de <code>4999</code> au lieu de <code>3999</code>. La fonction <code>from_roman()</code> est totalement générique : elle cherche juste les caractères représentant des nombres romains et les additionne, sans se soucier de combien de fois ils sont répétés. La seule raison pour laquelle il ne traitait <code>'MMMM'</code> avant, c’est que vous l’avez explicitement arrêté avec le modèle d’expression régulière correspondant.
<li>La fonction <code>to_roman()</code> doit seulement un petit changement dans le contrôle de portée. Comme vous avez vérifié <code>0 < n < 4000</code>, vous pouvez désormais vérifier <code>0 < n < 5000</code>. Et vous changez le message d’erreur que vous soulevez afin de refléter le nouvel intervalle acceptable (<code>1..4999</code> au lieu de <code>1..3999</code>). Vous n’avez pas besoin d’apporter des modifications au reste de la fonction, elle prend déjà les nouveaux cas en compte. (Il ajoute joyeusement <code>'M'</code> pour chaque mille qu’il trouve : pour <code>4000</code>, il va renvoyer <code>'MMMM'</code>. La seule raison pour laquelle il ne le faisait pas avant, c’est que vous l’avez explicitement arrêté par le test d’intervalle.)
</ol>

<p>Vous pourriez être sceptique que ces deux petits changements sont tout ce que vous avez besoin. Hey, voyez par vous-même.

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest9.py -v</kbd>
<samp>from_roman should fail with blank string ... ok
from_roman should fail with malformed antecedents ... ok
from_roman should fail with non-string input ... ok
from_roman should fail with repeated pairs of numerals ... ok
from_roman should fail with too many repeated numerals ... ok
from_roman should give known result with known input ... ok
to_roman should give known result with known input ... ok
from_roman(to_roman(n))==n for all n ... ok
to_roman should fail with negative input ... ok
to_roman should fail with non-integer input ... ok
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... ok

----------------------------------------------------------------------
Ran 12 tests in 0.203s

<a>OK  <span class=u>&#x2460;</span></a></samp></pre>
<ol>
<li>All the test cases pass. Stop coding.
</ol>

<p>Des tests unitaires compréhensifs signifient ne pas devoir croire un programmeur qui vous dit « Faites-moi confiance ».

<p class=a>&#x2042;

<h2 id=refactoring>Refactoring</h2>

<p>The best thing about comprehensive unit testing is not the feeling you get when all your test cases finally pass, or even the feeling you get when someone else blames you for breaking their code and you can actually <em>prove</em> that you didn&#8217;t. The best thing about unit testing is that it gives you the freedom to refactor mercilessly.

<p>Refactoring is the process of taking working code and making it work better. Usually, &#8220;better&#8221; means &#8220;faster&#8221;, although it can also mean &#8220;using less memory&#8221;, or &#8220;using less disk space&#8221;, or simply &#8220;more elegantly&#8221;. Whatever it means to you, to your project, in your environment, refactoring is important to the long-term health of any program.

<p>Here, &#8220;better&#8221; means both &#8220;faster&#8221; and &#8220;easier to maintain.&#8221; Specifically, the <code>from_roman()</code> function is slower and more complex than I&#8217;d like, because of that big nasty regular expression that you use to validate Roman numerals. Now, you might think, &#8220;Sure, the regular expression is big and hairy, but how else am I supposed to validate that an arbitrary string is a valid a Roman numeral?&#8221;

<p>Answer: there&#8217;s only 5000 of them; why don&#8217;t you just build a lookup table?  This idea gets even better when you realize that <em>you don&#8217;t need to use regular expressions at all</em>. As you build the lookup table for converting integers to Roman numerals, you can build the reverse lookup table to convert Roman numerals to integers. By the time you need to check whether an arbitrary string is a valid Roman numeral, you will have collected all the valid Roman numerals. &#8220;Validating&#8221; is reduced to a single dictionary lookup.

<p>And best of all, you already have a complete set of unit tests. You can change over half the code in the module, but the unit tests will stay the same. That means you can prove&nbsp;&mdash;&nbsp;to yourself and to others&nbsp;&mdash;&nbsp;that the new code works just as well as the original.

<p class=d>[<a href=examples/roman10.py>download <code>roman10.py</code></a>]
<pre class=pp><code>class OutOfRangeError(ValueError): pass
class NotIntegerError(ValueError): pass
class InvalidRomanNumeralError(ValueError): pass

roman_numeral_map = (('M',  1000),
                     ('CM', 900),
                     ('D',  500),
                     ('CD', 400),
                     ('C',  100),
                     ('XC', 90),
                     ('L',  50),
                     ('XL', 40),
                     ('X',  10),
                     ('IX', 9),
                     ('V',  5),
                     ('IV', 4),
                     ('I',  1))

to_roman_table = [ None ]
from_roman_table = {}

def to_roman(n):
    '''convert integer to Roman numeral'''
    if not (0 &lt; n &lt; 5000):
        raise OutOfRangeError('number out of range (must be 1..4999)')
    if int(n) != n:
        raise NotIntegerError('non-integers can not be converted')
    return to_roman_table[n]

def from_roman(s):
    '''convert Roman numeral to integer'''
    if not isinstance(s, str):
        raise InvalidRomanNumeralError('Input must be a string')
    if not s:
        raise InvalidRomanNumeralError('Input can not be blank')
    if s not in from_roman_table:
        raise InvalidRomanNumeralError('Invalid Roman numeral: {0}'.format(s))
    return from_roman_table[s]

def build_lookup_tables():
    def to_roman(n):
        result = ''
        for numeral, integer in roman_numeral_map:
            if n >= integer:
                result = numeral
                n -= integer
                break
        if n > 0:
            result += to_roman_table[n]
        return result

    for integer in range(1, 5000):
        roman_numeral = to_roman(integer)
        to_roman_table.append(roman_numeral)
        from_roman_table[roman_numeral] = integer

build_lookup_tables()</code></pre>

<p>Let&#8217;s break that down into digestable pieces. Arguably, the most important line is the last one:

<pre class='nd pp'><code>build_lookup_tables()</code></pre>

<p>You will note that is a function call, but there&#8217;s no <code>if</code> statement around it. This is not an <code>if __name__ == '__main__'</code> block; it gets called <em>when the module is imported</em>. (It is important to understand that modules are only imported once, then cached. If you import an already-imported module, it does nothing. So this code will only get called the first time you import this module.)

<p>So what does the <code>build_lookup_tables()</code> function do? I&#8217;m glad you asked.

<pre class=pp><code>to_roman_table = [ None ]
from_roman_table = {}
.
.
.
def build_lookup_tables():
<a>    def to_roman(n):                                <span class=u>&#x2460;</span></a>
        result = ''
        for numeral, integer in roman_numeral_map:
            if n >= integer:
                result = numeral
                n -= integer
                break
        if n > 0:
            result += to_roman_table[n]
        return result

    for integer in range(1, 5000):
<a>        roman_numeral = to_roman(integer)          <span class=u>&#x2461;</span></a>
<a>        to_roman_table.append(roman_numeral)       <span class=u>&#x2462;</span></a>
        from_roman_table[roman_numeral] = integer</code></pre>
<ol>
<li>This is a clever bit of programming&hellip; perhaps too clever. The <code>to_roman()</code> function is defined above; it looks up values in the lookup table and returns them. But the <code>build_lookup_tables()</code> function redefines the <code>to_roman()</code> function to actually do work (like the previous examples did, before you added a lookup table). Within the <code>build_lookup_tables()</code> function, calling <code>to_roman()</code> will call this redefined version. Once the <code>build_lookup_tables()</code> function exits, the redefined version disappears&nbsp;&mdash;&nbsp;it is only defined in the local scope of the <code>build_lookup_tables()</code> function.
<li>This line of code will call the redefined <code>to_roman()</code> function, which actually calculates the Roman numeral.
<li>Once you have the result (from the redefined <code>to_roman()</code> function), you add the integer and its Roman numeral equivalent to both lookup tables.
</ol>

<p>Once the lookup tables are built, the rest of the code is both easy and fast.

<pre class=pp><code>def to_roman(n):
    '''convert integer to Roman numeral'''
    if not (0 &lt; n &lt; 5000):
        raise OutOfRangeError('number out of range (must be 1..4999)')
    if int(n) != n:
        raise NotIntegerError('non-integers can not be converted')
<a>    return to_roman_table[n]                                            <span class=u>&#x2460;</span></a>

def from_roman(s):
    '''convert Roman numeral to integer'''
    if not isinstance(s, str):
        raise InvalidRomanNumeralError('Input must be a string')
    if not s:
        raise InvalidRomanNumeralError('Input can not be blank')
    if s not in from_roman_table:
        raise InvalidRomanNumeralError('Invalid Roman numeral: {0}'.format(s))
<a>    return from_roman_table[s]                                          <span class=u>&#x2461;</span></a></code></pre>
<ol>
<li>After doing the same bounds checking as before, the <code>to_roman()</code> function simply finds the appropriate value in the lookup table and returns it.
<li>Similarly, the <code>from_roman()</code> function is reduced to some bounds checking and one line of code. No more regular expressions. No more looping. O(1) conversion to and from Roman numerals.
</ol>

<p>But does it work? Why yes, yes it does. And I can prove it.

<pre class='screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest10.py -v</kbd>
<samp>from_roman should fail with blank string ... ok
from_roman should fail with malformed antecedents ... ok
from_roman should fail with non-string input ... ok
from_roman should fail with repeated pairs of numerals ... ok
from_roman should fail with too many repeated numerals ... ok
from_roman should give known result with known input ... ok
to_roman should give known result with known input ... ok
from_roman(to_roman(n))==n for all n ... ok
to_roman should fail with negative input ... ok
to_roman should fail with non-integer input ... ok
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... ok

----------------------------------------------------------------------
<a>Ran 12 tests in 0.031s                                                  <span class=u>&#x2460;</span></a>

OK</samp></pre>
<ol>
<li>Not that you asked, but it&#8217;s fast, too! Like, almost 10&times; as fast. Of course, it&#8217;s not entirely a fair comparison, because this version takes longer to import (when it builds the lookup tables). But since the import is only done once, the startup cost is amortized over all the calls to the <code>to_roman()</code> and <code>from_roman()</code> functions. Since the tests make several thousand function calls (the roundtrip test alone makes 10,000), this savings adds up in a hurry!
</ol>

<p>The moral of the story?

<ul>
<li>Simplicity is a virtue.
<li>Especially when regular expressions are involved.
<li>Unit tests can give you the confidence to do large-scale refactoring.
</ul>

<p class=a>&#x2042;

<h2 id=summary>Summary</h2>

<p>Unit testing is a powerful concept which, if properly implemented, can both reduce maintenance costs and increase flexibility in any long-term project. It is also important to understand that unit testing is not a panacea, a Magic Problem Solver, or a silver bullet. Writing good test cases is hard, and keeping them up to date takes discipline (especially when customers are screaming for critical bug fixes). Unit testing is not a replacement for other forms of testing, including functional testing, integration testing, and user acceptance testing. But it is feasible, and it does work, and once you&#8217;ve seen it work, you&#8217;ll wonder how you ever got along without it.

<p>These few chapters have covered a lot of ground, and much of it wasn&#8217;t even Python-specific. There are unit testing frameworks for many languages, all of which require you to understand the same basic concepts:

<ul>
<li>Designing test cases that are specific, automated, and independent
<li>Writing test cases <em>before</em> the code they are testing
<li>Writing tests that test good input and check for proper results
<li>Writing tests that test bad input and check for proper failure responses
<li>Writing and updating test cases to reflect new requirements
<li>Refactoring mercilessly to improve performance, scalability, readability, maintainability, or whatever other -ility you&#8217;re lacking
</ul>

<p class=v><a rel=prev href=unit-testing.html title='back to &#8220;Unit Testing&#8221;'><span class=u>&#x261C;</span></a> <a href=files.html rel=next title='onward to &#8220;Files&#8221;'><span class=u>&#x261E;</span></a>
<p class=c>&copy; 2001&ndash;11 <a href=about.html>Mark Pilgrim</a>
<script src=j/jquery.js></script>
<script src=j/prettify.js></script>
<script src=j/dip3.js></script>
